@INPROCEEDINGS{zeng2021architecturelevel,
  author={Zeng, Yu and Huang, Bo-Yuan and Zhang, Hongce and Gupta, Aarti and Malik, Sharad},
  booktitle={2021 IEEE/ACM International Conference On Computer Aided Design (ICCAD)}, 
  title={Generating Architecture-Level Abstractions from RTL Designs for Processors and Accelerators Part I: Determining Architectural State Variables}, 
  year={2021},
  volume={},
  number={},
  pages={1-9},
  keywords={Program processors;Automation;Design automation;Computer architecture;Size measurement;Hardware;Software;Hardware verification;accelerators;architectural abstraction;taint analysis;model checking},
  doi={10.1109/ICCAD51958.2021.9643584}}


@INPROCEEDINGS{xing2021processor,
  author={Xing, Yue and Lu, Huaixi and Gupta, Aarti and Malik, Sharad},
  booktitle={2021 Design, Automation & Test in Europe Conference & Exhibition (DATE)}, 
  title={Leveraging Processor Modeling and Verification for General Hardware Modules}, 
  year={2021},
  volume={},
  number={},
  pages={1130-1135},
  keywords={Instruction sets;Computer bugs;Hardware;Timing;Open source software;Formal verification},
  doi={10.23919/DATE51398.2021.9474194}}

@inproceedings{tan2022usagebased,
author = {Tan, Qinhan and Gupta, Aarti and Malik, Sharad},
title = {Usage-Based RTL Subsetting for Hardware Accelerators},
year = {2022},
isbn = {9781450392174},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3508352.3549391},
doi = {10.1145/3508352.3549391},
abstract = {Recent years have witnessed increasing use of domain-specific accelerators in computing platforms to provide power-performance efficiency for emerging applications. To increase their applicability within the domain, these accelerators tend to support a large set of functions, e.g. Nvidia's open-source Deep Learning Accelerator, NVDLA, supports five distinct groups of functions [17]. However, an individual use case of an accelerator may utilize only a subset of these functions. The unused functions lead to unnecessary overhead of silicon area, power, and hardware verification/hardware-software co-verification complexity. This motivates our research question: Given an RTL design for an accelerator and a subset of functions of interest, can we automatically extract a subset of the RTL that is sufficient for these functions and sequentially equivalent to the original RTL? We call this the Usage-based RTL Subsetting problem, referred to as the RTL subsetting problem in short. We first formally define this problem and show that it can be formulated as a program synthesis problem, which can be solved by performing expensive hyperproperty checks. To overcome the high cost, we propose multiple levels of sound over-approximations to construct an effective algorithm based on relatively less expensive temporal property checking and taint analysis for information flow checking. We demonstrate the acceptable computation cost and the quality of the results of our algorithm through several case studies of accelerators from different domains. The applicability of our proposed algorithm can be seen in its ability to subset the large NVDLA accelerator (with over 50,000 registers and 1,600,000 gates) for the group of convolution functions, where the subset reduces the total number of registers by 18.6\% and the total number of gates by 37.1\%.},
booktitle = {Proceedings of the 41st IEEE/ACM International Conference on Computer-Aided Design},
articleno = {73},
numpages = {9},
location = {San Diego, California},
series = {ICCAD '22}
}

@inproceedings{xing2022compositional,
author = {Xing, Yue and Lu, Huaixi and Gupta, Aarti and Malik, Sharad},
title = {Compositional Verification Using a Formal Component and Interface Specification},
year = {2022},
isbn = {9781450392174},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3508352.3549341},
doi = {10.1145/3508352.3549341},
abstract = {Property-based specification s uch a s SystemVerilog Assertions (SVA) uses mathematical logic to specify the temporal behavior of RTL designs which can then be formally verified using model checking algorithms. These properties are specified for a single component (which may contain other components in the design hierarchy). Composing design components that have already been verified requires additional verification since incorrect communication at their interface may invalidate the properties that have been checked for the individual components. This paper focuses on a specification for their interface which can be checked individually for each component, and which guarantees that refinement-based properties checked for each component continue to hold after their composition. We do this in the setting of the Instruction-level Abstraction (ILA) specification and verification methodology. The ILA methodology provides a uniform specification for processors, accelerators and general modules at the instruction-level, and the automatic generation of a complete set of correctness properties for checking that the RTL model is a refinement of the ILA specification. We add an interface specification to model the inter-ILA communication. Further, we use our interface specification to generate a set of interface checking properties that check that the communication between the RTL components is correct. This provides the following guarantee: if each RTL component is a refinement of its ILA specification and the interface checks pass, then the RTL composition is a refinement of the ILA composition. We have applied the proposed methodology to six case studies including parts of large-scale designs such as parts of the FlexASR and NVDLA machine learning accelerators, demonstrating the practical applicability of our method.},
booktitle = {Proceedings of the 41st IEEE/ACM International Conference on Computer-Aided Design},
articleno = {72},
numpages = {9},
location = {San Diego, California},
series = {ICCAD '22}
}

@INPROCEEDINGS{zeng2022automatic,
  author={Zeng, Yu and Gupta, Aarti and Malik, Sharad},
  booktitle={2022 Design, Automation & Test in Europe Conference & Exhibition (DATE)}, 
  title={Automatic Generation of Architecture-Level Models from RTL Designs for Processors and Accelerators}, 
  year={2022},
  volume={},
  number={},
  pages={460-465},
  keywords={Program processors;Instruction sets;Writing;Hardware;Optimization;Clocks;Hardware modelling;accelerators;architectural abstraction},
  doi={10.23919/DATE54114.2022.9774527}}


@INPROCEEDINGS{xing2022generalizing,
  author={Xing, Yue and Gupta, Aarti and Malik, Sharad},
  booktitle={2022 27th Asia and South Pacific Design Automation Conference (ASP-DAC)}, 
  title={Generalizing Tandem Simulation: Connecting High-level and RTL Simulation Models}, 
  year={2022},
  volume={},
  number={},
  pages={154-159},
  keywords={Adaptation models;Program processors;Instruction sets;Design methodology;Switches;Manuals;Hardware},
  doi={10.1109/ASP-DAC52403.2022.9712564}}

@inbook{huang2025invited,
author = {Huang, Bo-Yuan and Zhang, Hongce and Gupta, Aarti and Malik, Sharad},
title = {Invited: Generalizing the ISA to the ILA: A Software/Hardware Interface for Accelerator-Rich Platforms},
year = {2025},
isbn = {9798350323481},
publisher = {IEEE Press},
url = {https://doi.org/10.1109/DAC56929.2023.10247894},
abstract = {This paper presents the Instruction-Level Abstraction (ILA) as a formal software/hardware interface for accelerator-rich platforms. The ILA provides a common framework for formal functional specification of processors and accelerator behavior, verifying their implementations, and reasoning about software-hardware interactions of programs with accelerators. The ILA-MCM specification extends the ILA to enable reasoning about interactions of accelerators with other compute engines through shared memory. The 3LA compilation flow for accelerators uses the ILA model to bridge the gap between fine-grain compiler intrinsics and coarse-grain accelerator operations.},
booktitle = {Proceedings of the 60th Annual ACM/IEEE Design Automation Conference},
pages = {1–4},
numpages = {4}
}

@article{lu2023soc,
    author = {Lu, Huaixi and Xing, Yue and Gupta, Aarti and Malik, Sharad},
    title = {SoC Protocol Implementation Verification Using Instruction-Level Abstraction Specifications},
    year = {2023},
    issue_date = {November 2023},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    volume = {28},
    number = {6},
    issn = {1084-4309},
    url = {https://doi.org/10.1145/3610292},
    doi = {10.1145/3610292},
    abstract = {In modern systems-on-chips, several hardware protocols are used for communication and interaction among different modules. These protocols are complex and need to be implemented correctly for correct operation of the system-on-chip. Therefore, protocol verification has received significant attention. However, this verification is often limited to checking high-level properties on a protocol specification or an implementation. Verifying these properties directly on an implementation faces scalability challenges due to its size and design complexity. Further, even after some high-level properties are verified, there is no guarantee that an implementation fully complies with a given specification, even if the same properties have also been checked on the specification. We address these challenges and gaps by adding a layer of component specifications, one for each component in the protocol implementation, and specifying and verifying the interactions at the interfaces between each pair of communicating components. We use the recently proposed formal model termed Instruction-Level Abstraction (ILA) as a component specification, which includes an interface specification for the interactions in composing different components. The use of ILA models as component specifications allows us to decompose the complete verification task into two sub-tasks: checking that the composition of ILAs is sequentially equivalent to a verified formal protocol specification, and checking that the protocol implementation is a refinement of the ILA composition. This check requires that each component implementation is a refinement of its ILA specification and includes interface checks guaranteeing that components interact with each other as specified. We have applied the proposed ILA-based methodology for protocol verification to several third-party design case studies. These include an AXI on-chip communication protocol, an off-chip communication protocol, and a cache coherence protocol. For each system, we successfully detected bugs in the implementation, and show that the full formal verification can be completed in reasonable time and effort.},
    journal = {ACM Trans. Des. Autom. Electron. Syst.},
    month = oct,
    articleno = {89},
    numpages = {24},
    keywords = {refinement checking, sequential equivalence checking, formal verification, instruction-level abstraction, hardware protocol specification, System-on-chip}
}

@inproceedings{zeng2025automatic,
    author = {Zeng, Yu and Gupta, Aarti and Malik, Sharad},
    title = {Automatic Generation of Cycle-Accurate Timing Models from RTL for Hardware Accelerators},
    year = {2025},
    isbn = {9798400710773},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    url = {https://doi.org/10.1145/3676536.3676657},
    doi = {10.1145/3676536.3676657},
    abstract = {Simulation is widely used during different stages of hardware development. This paper focuses on one specific type of simulation - cycle-accurate timing simulation, which measures the number of cycles for a given computation. We propose a pioneering approach for automatically generating cycle-accurate timing models of hardware accelerators from their RTL designs based on dependency analysis and constraint solving, making this the first technique of its kind in this domain. We demonstrate the applicability of our approach for six non-trivial designs. We show that our method achieves a 1.5x-6.9x speedup for cycle-accurate simulation over RTL models for computation-intensive accelerators, demonstrating its effectiveness. Our approach provides a cost-effective way to quickly determine the execution time of accelerators.},
    booktitle = {Proceedings of the 43rd IEEE/ACM International Conference on Computer-Aided Design},
    articleno = {155},
    numpages = {8},
    location = {Newark Liberty International Airport Marriott, New York, NY, USA},
    series = {ICCAD '24}
}

@article{huang2024applicationlevel,
    author = {Huang, Bo-Yuan and Lyubomirsky, Steven and Li, Yi and He, Mike and Smith, Gus Henry and Tambe, Thierry and Gaonkar, Akash and Canumalla, Vishal and Cheung, Andrew and Wei, Gu-Yeon and Gupta, Aarti and Tatlock, Zachary and Malik, Sharad},
    title = {Application-level Validation of Accelerator Designs Using a Formal Software/Hardware Interface},
    year = {2024},
    issue_date = {March 2024},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    volume = {29},
    number = {2},
    issn = {1084-4309},
    url = {https://doi.org/10.1145/3639051},
    doi = {10.1145/3639051},
    abstract = {Ideally, accelerator development should be as easy as software development. Several recent design languages/tools are working toward this goal, but actually testing early designs on real applications end-to-end remains prohibitively difficult due to the costs of building specialized compiler and simulator support. We propose a new first-in-class, mostly automated methodology termed “3LA” to enable end-to-end testing of prototype accelerator designs on unmodified source applications. A key contribution of 3LA is the use of a formal software/hardware interface that specifies an accelerator’s operations and their semantics. Specifically, we leverage the Instruction-level Abstraction (ILA) formal specification for accelerators that has been successfully used thus far for accelerator implementation verification. We show how the ILA for accelerators serves as a software/hardware interface, similar to the Instruction Set Architecture for processors, that can be used for automated development of compilers and instruction-level simulators. Another key contribution of this work is to show how ILA-based accelerator semantics enables extending recent work on equality saturation to auto-generate basic compiler support for prototype accelerators in a technique we term “flexible matching.” By combining flexible matching with simulators auto-generated from ILA specifications, our approach enables end-to-end evaluation with modest engineering effort. We detail several case studies of 3LA, which uncovered an unknown flaw in a recently published accelerator and facilitated its fix.},
    journal = {ACM Trans. Des. Autom. Electron. Syst.},
    month = feb,
    articleno = {35},
    numpages = {25},
    keywords = {Accelerator, domain-specific language, compilation, validation, software/hardware interface}
}

@ARTICLE{lu2025hierarchical,
  author={Lu, Huaixi and Xing, Yue and Gupta, Aarti and Malik, Sharad},
  journal={IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems}, 
  title={Hierarchical Formal Verification of Hardware}, 
  year={2025},
  volume={44},
  number={9},
  pages={3629-3642},
  keywords={Hardware;Scalability;Formal verification;Design automation;Computer architecture;Vectors;Training;Hardware acceleration;Explosions;Deep learning;Formal verification (FV);hardware;hierarchical verification;refinement checking (RC)},
  doi={10.1109/TCAD.2025.3541567}}

@inproceedings{huang2018formal,
    title = {{Formal Security Verification of Concurrent Firmware in SoCs using Instruction-Level Abstraction for Hardware}},
    year = {2018},
    booktitle = {Proc. Design Automation Conference},
    author = {Huang, Bo-Yuan and Ray, Sayak and Gupta, Aarti and Fung, Jason M. and Malik, Sharad},
    pages = {91}
}

@inproceedings{zhang2018ila,
    title = {{ILA-MCM: Integrating Memory Consistency Models with Instruction-Level Abstractions for Heterogeneous System-on-Chip Verification}},
    year = {2018},
    booktitle = {Proc. Conf. Formal Methods in Computer-Aided Design},
    author = {Zhang, Hongce and Trippel, Caroline and Manerkar, Yatin A and Gupta, Aarti and Martonosi, Margaret and Malik, Sharad},
    pages = {1--10}
}

@article{huang2018instructionb,
    title = {{Instruction-Level Abstraction (ILA): A Uniform Specification for System-on-Chip (SoC) Verification}},
    year = {2018},
    journal = {ACM Transactions on Design Automation of Electronic Systems},
    author = {Huang, Bo-Yuan and Zhang, Hongce and Subramanyan, Pramod and Vizel, Yakir and Gupta, Aarti and Malik, Sharad},
    number = {1},
    month = {8},
    pages = {10},
    volume = {24}
}

@inproceedings{malikinvited,
    title = {{INVITED : Specification and Modeling for Systems-on-Chip Security Verification}},
    year = {2016},
    booktitle = {Proc. of Design Automation Conference},
    author = {Malik, Sharad and Subramanyan, Pramod},
    pages = {1--6}
}

@article{subramanyan2018template,
    title = {{Template-Based Parameterized Synthesis of Uniform Instruction-Level Abstractions for SoC Verification}},
    year = {2018},
    journal = {IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems},
    author = {Subramanyan, Pramod and Huang, Bo-Yuan and Vizel, Yakir and Gupta, Aarti and Malik, Sharad},
    number = {8},
    pages = {1692--1705},
    volume = {37}
}

@inproceedings{subramanyan2015template,
    title = {{Template-based Synthesis of Instruction-Level Abstractions for SoC Verification}},
    year = {2017},
    booktitle = {Proceedings of the Conference on Formal Methods in Computer-Aided Design},
    author = {Subramanyan, Pramod and Vizel, Yakir and Ray, Sayak and Malik, Sharad},
    pages = {160--167},
    isbn = {9780983567851},
    doi = {10.1109/FMCAD.2015.7542266}
}

@inproceedings{subramanyan2016verifying,
    title = {{Verifying Information Flow Properties of Firmware using Symbolic Execution}},
    year = {2016},
    booktitle = {Proceedings of the Conference on Design, Automation and Test in Europe},
    author = {Subramanyan, Pramod and Malik, Sharad and Khattri, Hareesh and Maiti, Abhranil and Fung, Jason},
    pages = {1393--1398},
    doi = {10.3850/9783981537079{\_}0793}
}

@inproceedings{Xing2018AVerification,
    title = {{A Formal Instruction-Level GPU Model for Scalable Verification}},
    year = {2018},
    booktitle = {Proc. Int. Conf. Computer-Aided Design},
    author = {Xing, Yue and Huang, Bo-Yuan and Gupta, Aarti and Malik, Sharad},
    pages = {130--137},
    isbn = {9781450359504},
    doi = {10.1145/3240765.3240771},
    issn = {10923152}
}

@inproceedings{Huang2019ILAng:Abstractions,
    title = {{ILAng: A Modeling and Verification Platform for SoCs using Instruction-Level Abstractions}},
    year = {2019},
    booktitle = {Proc. Int. Conf. Tools and Algorithms for the Construction and Analysis of Systems},
    author = {Huang, Bo-Yuan and Zhang, Hongce and Gupta, Aarti and Malik, Sharad},
    pages = {351--357},
    isbn = {9783030174613},
    doi = {10.1007/978-3-030-17462-0{\_}21},
    issn = {16113349}
}

@inproceedings{zhang2020synthesizing,
  title = {{Synthesizing Environment Invariants for Modular Hardware Verification}},
  author = {Zhang, Hongce and Yang, Weikun and Fedyukovich, Grigory and Gupta, Aarti and Malik, Sharad},
  booktitle = {Proc. Int. Conf. Verification, Model Checking, and Abstract Interpretation},
  pages = {202--225},
  year = {2020},
  organization = {Springer}
}
